<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ph√°p B·∫£o Ph√∫c L·∫°c Chatbot</title>

  <!-- N·ªÄN TH∆Ø∆†NG HI·ªÜU -->
  <style>
    :root { --ink:#111; --muted:#f1f1f1; --line:#eee; --brand:#16a085; --accent:#a855f7; }
    html,body { height:100%; }
    body {
      margin:0; font:16px/1.6 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color:var(--ink);
      /* n·ªÅn d·ªãu, c√≥ hoa sen m·ªù */
      background:
        radial-gradient(1200px 600px at 10% -10%, #f8f5ff 0, transparent 50%),
        radial-gradient(1000px 400px at 120% 20%, #e8fff6 0, transparent 45%),
        #fff;
    }
    .container { max-width:920px; margin:40px auto; padding:0 16px; }
    .brand { display:flex; align-items:center; gap:12px; margin-bottom:18px; }
    .brand h1 { margin:0; font-size:26px; font-weight:800; letter-spacing:.2px; }
    .brand small { color:#6b7280; margin-left:6px; }

    /* Logo sen inline */
    .lotus { width:28px; height:28px; display:inline-block; }

    .card { border:1px solid var(--line); border-radius:18px; background:#fff; box-shadow:0 10px 30px rgba(0,0,0,.04); }
    #messages { max-height:64vh; min-height:320px; overflow:auto; padding:18px; contain:content; }
    .bubble { padding:12px 14px; margin:10px 0; border-radius:16px; }
    .bubble.user { background:var(--muted); color:var(--ink); margin-left:auto; width:fit-content; max-width:82%; }
    .bubble.assistant { background:#fff; border:1px solid var(--line); max-width:82%; }
    .bubble.note { font-size:12px; opacity:.75; text-align:center; background:transparent; border:none; }
    .composer { display:flex; gap:10px; padding:12px; border-top:1px solid var(--line); background:#fff;
                border-radius:0 0 18px 18px; }
    #chat-input { flex:1; padding:12px 14px; border:1px solid #ddd; border-radius:12px; }
    #send-btn { padding:12px 18px; border-radius:12px; border:0; background:var(--brand); color:#fff; cursor:pointer; font-weight:600; }
    #send-btn:disabled { opacity:.6; cursor:not-allowed; }
    .hint { font-size:12px; color:#666; margin-top:10px; }

    /* render Markdown trong c√¢u tr·∫£ l·ªùi */
    .assistant h1,.assistant h2,.assistant h3{ margin:6px 0 8px; }
    .assistant p, .assistant ul, .assistant ol { margin:8px 0; }
    .assistant ul, .assistant ol { padding-left:22px; }
    .assistant code { background:#f6f6f6; padding:2px 6px; border-radius:6px; }
    .assistant a { color:#0ea5e9; text-decoration:none; }
    .assistant a:hover { text-decoration:underline; }
  </style>

  <!-- Markdown + XSS sanitize (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
</head>
<body>
  <div class="container">
    <div class="brand">
      <!-- Logo hoa sen inline (SVG) -->
      <svg class="lotus" viewBox="0 0 24 24" fill="none" aria-hidden="true">
        <path d="M12 3c1.8 2.7 2.6 5.1 2.4 7.2 1.7-.7 3.3-2 4.6-4-0.1 3-1.2 5.2-3 6.7 2 .1 4-.5 6-2-1.1 3.8-3.6 6-7.5 6.7.7.6 1.5 1.3 2.3 2.3-2.5-.2-4.3-1-5.2-2-0.9 1-2.7 1.8-5.2 2 .8-1 1.6-1.7 2.3-2.3-3.9-.7-6.4-2.9-7.5-6.7 2 .9 4 1.1 6 2-1.8-1.5-2.9-3.7-3-6.7 1.3 2 2.9 3.3 4.6 4C9.4 8.1 10.2 5.7 12 3z" fill="#a855f7"/>
      </svg>
      <h1>Ph√°p B·∫£o Ph√∫c L·∫°c Chatbot <small>üßò T·ª´ h√≤a ‚Äì Ch√°nh ki·∫øn ‚Äì L·ª£i l·∫°c</small></h1>
    </div>

    <form id="chat-form" class="card" autocomplete="off">
      <div id="messages" aria-live="polite"></div>
      <div class="composer">
        <input id="chat-input" name="message" placeholder="Nam m√¥ B·ªïn S∆∞ Th√≠ch Ca M√¢u Ni Ph·∫≠t üôè B·∫°n mu·ªën h·ªèi ƒëi·ªÅu g√¨?" />
        <button id="send-btn" type="submit">G·ª≠i</button>
      </div>
    </form>

    <div class="hint">N·∫øu trang ch·∫≠m sau v√†i ng√†y d√πng, h·ªá th·ªëng s·∫Ω t·ª± r√∫t g·ªçn l·ªãch s·ª≠ hi·ªÉn th·ªã ƒë·ªÉ nh·∫π m√°y.</div>
  </div>

  <script>
  // ===================== C·∫§U H√åNH =====================
  const API_URL         = '/api/chat';         // JSON (fallback)
  const API_URL_STREAM  = '/api/chat-stream';  // SSE (streaming th·ª±c)

  // Gi·ªõi h·∫°n s·ªë bong b√≥ng ƒë·ªÉ tr√°nh ch·∫≠m
  const MAX_NODES = 120;
  const TRIM_BATCH = 20;

  // ===================== THAM CHI·∫æU UI =====================
  const form  = document.getElementById('chat-form');
  const pane  = document.getElementById('messages');
  const input = document.getElementById('chat-input');
  const send  = document.getElementById('send-btn');

  function appendBubble(text, who='assistant') {
    const el = document.createElement('div');
    el.className = 'bubble ' + (who === 'user' ? 'user' : 'assistant');
    // m·∫∑c ƒë·ªãnh hi·ªÉn th·ªã text thu·∫ßn (an to√†n khi stream)
    el.textContent = text ?? '';
    pane.appendChild(el);

    if (pane.children.length > MAX_NODES) {
      for (let i=0;i<TRIM_BATCH;i++) if (pane.firstChild) pane.removeChild(pane.firstChild);
      if (!pane.dataset.truncated) {
        const note = document.createElement('div');
        note.className = 'bubble note';
        note.textContent = 'ƒê√£ r√∫t g·ªçn l·ªãch s·ª≠ hi·ªÉn th·ªã ƒë·ªÉ trang m∆∞·ª£t h∆°n.';
        pane.insertBefore(note, pane.firstChild);
        pane.dataset.truncated = '1';
      }
    }
    pane.scrollTop = pane.scrollHeight;
    return el; // üëâ tr·∫£ v·ªÅ element ƒë·ªÉ c·∫≠p nh·∫≠t n·ªôi dung khi stream
  }

  function finalizeAsMarkdown(bubbleEl, text) {
    // Khi stream xong, ƒë·ªïi sang HTML Markdown an to√†n (ƒë·∫πp h∆°n)
    const html = DOMPurify.sanitize(marked.parse(text || ''));
    bubbleEl.innerHTML = html;
  }

  function setBusy(b) {
    send.disabled = b; input.readOnly = b;
    if (b) { send.dataset._t = send.textContent; send.textContent = 'ƒêang g·ª≠i‚Ä¶'; }
    else { send.textContent = send.dataset._t || 'G·ª≠i'; }
  }

  // ===================== G·ªåI API (FALLBACK JSON) =====================
  async function callAPI(message, history) {
    const res = await fetch(API_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ message, history }),
    });
    const ct = res.headers.get('content-type') || '';
    if (!res.ok) {
      const errText = ct.includes('application/json') ? JSON.stringify(await res.json(), null, 2) : await res.text();
      throw new Error(`HTTP ${res.status} ${res.statusText}\n${errText}`);
    }
    if (ct.includes('application/json')) {
      const data = await res.json();
      return data?.reply || data?.choices?.[0]?.message?.content || JSON.stringify(data, null, 2);
    }
    return await res.text();
  }

  // ===================== STREAM T·ª™ SSE =====================
  async function streamAPI(message, history, onToken, onDone) {
    const res = await fetch(API_URL_STREAM, {
      method:'POST',
      headers:{ 'Content-Type':'application/json' },
      body: JSON.stringify({ message, history }),
    });

    const ct = res.headers.get('content-type') || '';
    if (!res.ok) {
      // N·∫øu API stream l·ªói, quƒÉng ra ƒë·ªÉ d√πng fallback JSON
      const t = ct.includes('application/json') ? JSON.stringify(await res.json(), null, 2) : await res.text();
      throw new Error(`HTTP ${res.status} ${res.statusText}\n${t}`);
    }

    // N·∫øu ƒë√∫ng SSE
    if (ct.includes('text/event-stream')) {
      const reader = res.body.getReader();
      const decoder = new TextDecoder('utf-8');
      let buffer = '';
      let acc = '';

      while (true) {
        const { value, done } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });

        // t√°ch theo g√≥i SSE (k·∫øt th√∫c b·∫±ng \n\n)
        const events = buffer.split('\n\n');
        buffer = events.pop() || '';

        for (const evt of events) {
          const lines = evt.split('\n').filter(Boolean);
          for (const line of lines) {
            if (!line.startsWith('data:')) continue;
            const data = line.slice(5).trim();
            if (data === '[DONE]') { onDone && onDone(acc); return; }
            try {
              const json = JSON.parse(data);
              const token = json?.choices?.[0]?.delta?.content || '';
              if (token) { acc += token; onToken && onToken(acc, token); }
            } catch { /* heartbeat / keepalive */ }
          }
        }
      }
      onDone && onDone(acc);
      return;
    }

    // Kh√¥ng ph·∫£i SSE ‚Üí fallback: ƒë·ªçc to√†n b·ªô
    const reply = await callAPI(message, history);
    onToken && onToken(reply, reply);
    onDone && onDone(reply);
  }

  // ===================== G·ª¨I TIN =====================
  form.addEventListener('submit', async (ev) => {
    ev.preventDefault();
    try {
      const msg = (input.value || '').trim();
      if (!msg) return;

      // Bong b√≥ng c·ªßa user
      appendBubble(msg, 'user');
      input.value = ''; setBusy(true);

      // L·∫•y 50 m·∫©u g·∫ßn nh·∫•t l√†m history
      const history = Array.from(pane.querySelectorAll('.bubble'))
        .slice(-50)
        .map(el => ({ role: el.classList.contains('user') ? 'user' : 'assistant', content: el.textContent || '' }));

      // T·∫°o bubble r·ªóng cho bot ƒë·ªÉ stream v√†o
      const botBubble = appendBubble('', 'assistant');

      // STREAM ‚Äî c·∫≠p nh·∫≠t ch·ªØ ƒëang ch·∫°y (text thu·∫ßn)
      await streamAPI(msg, history, (acc) => {
        botBubble.textContent = acc;
        pane.scrollTop = pane.scrollHeight;
      }, (fullText) => {
        // khi xong, ƒë·ªïi sang HTML Markdown ƒë·∫πp
        finalizeAsMarkdown(botBubble, fullText);
      });

    } catch (err) {
      console.error('[Chat][Submit]', err);
      appendBubble('L·ªói: ' + (err?.message || err), 'assistant');
    } finally {
      setBusy(false); input.focus();
    }
  });

  // L·ªùi ch√†o ƒë·∫ßu trang
  appendBubble('Nam m√¥ B·ªïn S∆∞ Th√≠ch Ca M√¢u Ni Ph·∫≠t! B·∫°n ƒëang mu·ªën t√¨m hi·ªÉu ƒëi·ªÅu g√¨ trong Ph·∫≠t ph√°p?');

  console.log('[Chat] Ready ‚úÖ');
  </script>
</body>
</html>
